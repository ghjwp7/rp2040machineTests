.. -*- mode: rst -*-  #  Readme for calibratePulse8 - jiw - Jan 2025
..  Use `restview <fn>` to view `<fn>` in html in browser
..  Browser page will update whenever a changed version is stored.

==================================================
PIO pulse measurement calibration program 8b
==================================================

**Context:** For a pulse-timing application in a different repo,
signals recur in a series of 0.1 second windows, with dozens of pulses
per window and pulse widths ranging from around 8 us up to about 80
us.  `calibratePulse8` is a test demo of one technique for timing
edges of pulses.  This program uses regularly-repeating square waves
to verify that the counter doesn't lose or gain count cycles.  In
later code, the mechanisms used here may allow an RP2040 app to time 4
independent signal sets of erratic pulses at a resolution of 2
system-clock cycles.

Note, 8b testing requires a jumper between two pins that are selected
via declarations like ``W_out_Pin=const(13)`` and
``C_in_Pin=const(12)).``

Note!  This version sets system frequency as specified in a line like
``SysFreq=const(120000000)`` or ``SysFreq=const(180000000)``, ie, at
other than 125 MHz.  Intent: Get nicer numbers for nominal counts, to
make errors show up more obviously.  Also note: debug printing usually
is commented out before commits but not necessarily always.

At present, `calibratePulse8` handles data from the PIO fifo on the
fly.  It would be better if data were handled via a good-sized
buffers, rather than a small fifo, to allow more time leeway when
bursty pulse sequences occur.  At some point, if noise or other
factors necessitate more-elaborate data processing, it may be
necessary to apply ``@micropython.viper`` instead of
``@micropython.native`` to time-critical processing.  Both of those
decorators compile python code to native machine code.  Viper is
faster but requires typing etc.  Code as of 21 Jan 2025 can keep up
with analyzing a 12 kHz signal, but stumbles at 13 KHz.

Future:  Use DMA storage buffers + 2 CPUs


How the counter works
---------------------------

**Overview:** An RP2040 PIO state machine is used to poll a pin while
decrementing a counter.  When an edge change occurs, a two-word packet
with counter value and an edge-polarity mark-code is stored.  Storing
the counter takes up a few cycles, during which the counter doesn't
decrement.  However, PIO code uses extra decrement operations to make
up for that gap, as explained in a later section.

==========  ============================================  =======
Mark Code      Denotation                                 Value
==========  ============================================  =======
GFall        Falling-edge packet                           0
GRise        Rising-edge packet                            1
==========  ============================================  =======

**Details:** The state counter machine has two parts, similar in form.
One looks for rising edges, the other for falling edges, in spin loops
that take two state machine cycles and decrement a register by 1
during each loop.  This makes a 2-machine-cycles-per-count counter,
thus a 62.5 MHz count loop if system clock is 125 MHz.  Whenever an
edge change is detected, the state machine stores a two-word data
packet, with a ``GRise`` or ``GFall`` mark-code for rising or falling
in the first word and a counter value in the second.  Move, set, and
push operations to store mark words and values use up several cycles
per edge, during which the usual every-other-cycle decrements get
missed.  This requires make-up decrements, as covered in more detail
in section "Make-up Decrements Tests".

The pin test available in a PIO State Machine does a jump if a pin is
set.  The rising-edge spin-while-low loop tests a pin, and if it's
set, jumps to store data, else falls into the decrement+jump that
closes the spin loop.  On the other hand, the falling-edge
spin-while-high loop does a decrement first, then uses a pin-test jump
to close the spin loop.

**What main() does** -- ``main()`` prints out setup info (eg, system
frequency and wave frequency and duty); uses ``makeSMwave`` to set up
the wave machine; calls ``takeReadings()`` to run test and collect
data; displays summary report; and calls ``shoHisto()`` to print out
histogram data that was accumulated during the readings phase.  The
outputs show how many pulses were measured as in their expected time
ranges.

**What takeReadings() does** -- This routine begins by creating lists
of histogram-bin limits, and zeroing counts in bins.  Next, it has a
data collection loop headed by ``while i < NEdges:``.  In that
``while`` loop, statements ``mark = csm.get()`` and ``xlast = csm.get()``
do blocking reads from the counter's fifo.  The first of those reads
is followed by a loop that keeps reading if ``mark`` isn't a GRise or
GFall value.  Each extra read counts as a skip (but not as an edge).
A skip may occur at start of process.  Once an ok mark and value are
available, ``d = xlast - xprev; xprev = xlast`` computes ``d``, which
is the time in counts since previous edge detection.  Finally, a
histogram bin for value ``d`` is located and incremented.

When enough edges have been processed, ``takeReadings()`` returns its
accumulated data to ``main()``, which as noted above calls
``shoHisto()`` to print it out.  See following output, with comments
after.

Output - 343500 edges, 12 KHz wave frequency
--------------------------------------------
::

  Making state machine instances
  System frequency  = 125000000 Hz,      8.00 ns
  Counts per second =  62500000 Hz,     16.00 ns
    Wave frequency  =     12000 Hz,  83333.34 ns
  About to get 343500 edges in 14.3 sec. with wave type 3
  Processed 343500 items with 2 skips in 14.312506 sec
  
  Clock time     14312506 us    Clock-count total diff    66.000 us
  Counted time   14312440.000 us  Clock-count avg diff     0.192 ns
  Predicted time 14312500.000 us     less counted time    60.000 us
  
                       Histogram Results                      
  171750 GR:   5046 nom,  5045.0625 avle    ≤4996: 1  =5045: 161015  =5046: 10734  
  171750 GF:    163 nom,   163.2500 avle    =163: 128812  =164: 42938  
  Total average (less edges) =  5208.3125, nomCy 5208.333, total nom 5209

Above, the "About to get..." and "Processed..." lines were separated
by about 14.3 seconds as the program collected data.  In the GR: and
GF: Histogram Result lines, one rising-edge count was some value at or
below 4996.  In single-value bins (vs ranges), count 5045 appeared
161015 times, 5046 10734 times, and so forth.  Other output fields are
explained in the following table.

========================  ================  =========================================
Field Name                Example Value         Purpose
========================  ================  =========================================
Clock time                 14312506 us      t1-t0, ``ticks_us()`` readings around loop
Clock-count total diff     66.000 us        Clock time minus Counted time
Counted time               14312440.000 us  (Last count)*(microseconds per count)
Clock-count avg diff       0.192 ns         (Clock-count total diff)/(number of items)
Predicted time             14312500.000 us  (Number of edges)*(wave period)
less counted time          60.000 us        Predicted time minus Counted time
GR:                                         Histogram data for rising edge times
GF:                                         Histogram data for falling edge times
nom                        5046 nom         Number of counts expected for phase of wave
avle                       5045.0625 avle   Average based on histo data, less extremes
total nom                  5209             Sum of noms -- GR nom + GF nom
Total average less edges   5208.3125        Sum of avle values
nomCy                      5208.333         Actual expected counts per wave cycle
========================  ================  =========================================

Note, ignore any nomCy values below shown as NA (due to former code error).

**to do:** have a dma with no read or write advance.  in=TIMELR, out=mem,
with irq to copy the mem word to small buffer + circ buffer.
  
**was to do**, now works ok: have front loops in counter sm to wait
for up, wait for down, jump to store falling edge, to synchronize csm
and make later analysis cleaner.  This didn't help at first, because
the wait-for-high-level loop was in main thread, not PIO, and seemed
to lose 50-70 cycles.  But moving the csm into PIO 1 -- rather than
having csm and wsm in same PIO -- freed up a couple of words to allow
wait-for-high-level loop to be in PIO as part of csm, which works well.

**was to do**, gives ok results, but needs work: with small buffer +
circ buffer save first 8 & last 8 words, to get better comparison of
Counted time vs Predicted time.  Data collection for this is in code
now.  Example of output for this feature is like last lines of
following, which ran at 180 MHz::

  Making state machine instances
  System frequency  = 180000000 Hz,      5.56 ns
  Counts per second =  90000000 Hz,     11.11 ns
    Wave frequency  =     10000 Hz, 100000.00 ns  from SM freq 250000
  About to get 20000 edges in 1.0 sec. with wave type 3
  Processed 20000 items with 0 skips in 0.999971 sec
  
  Clock time       999971 us   Clock-count total diff  -22.7 us
  Counted time     999993.7 us   Clock-count avg diff   -1.134 ns
  Predicted time  1000000.0 us      less counted time    6.3 us
  
                       Histogram Results                      
   10000 GR:   8640 nom,  8640.0000 avle    ≤8590: 1  =8640: 9999  
   10000 GF:    360 nom,   360.0000 avle    ≤310: 1  =360: 9999  
  Total average (less edges) = 9000.00000, nomCy 9000.00000, total nom 9000
  krb=[8430, 17430] kre=[89990430, 89999430]  kfb=[0, 8790]  kfe=[89981790, 89990790]
  krn=89991000   krn/nomCy: 9999.000000   krn%|nomCy|: 0
  kfn=89982000   kfn/nomCy: 9998.000000   kfn%|nomCy|: 0

343600 vs 344000 edges
---------------------------------------------

The next two outputs are from runs that captured 343600 and 344000
edges, respectively, the former running just fine, the latter not.

The first run detected 171800 rising and falling edges each, totalling
343600 edges, as expected. 171799 edges were in the main bins of
histogram results, ie 6054 counts for down time and 196 counts for up
time, with one rising edge count 50 or more away from the main bin.

The second run detected 344000 edges, as expected, but somehow counted
10 more rising than falling edges.  This is due to an unexplained
problem in the code or processing method.  64 skips occurred in
processing; that is, 64 times when a GRise or GFall mark code was
expected, something else occurred, indicating fifo might have filled
or something else happened.  This may be due to an unexplained problem
in the code.  Note, 10000*2**32/125000000 ~ 343597.38, where
10000 is wave frequency, 32 is register size, and 125000000 is the
system frequency the test ran at, and some overflow still to be found
may be occurring somewhere in the code.

::

  Making state machine instances
  System frequency  = 125000000 Hz,      8.00 ns
  Counts per second =  62500000 Hz,     16.00 ns
    Wave frequency  =     10000 Hz, 100000.00 ns
  About to get 343600 edges in 17.2 sec. with wave type 3
  Processed 343600 items with 2 skips in 17.180216 sec
  
  Clock time     17180217 us    Clock-count total diff   218.000 us
  Counted time   17179998.000 us  Clock-count avg diff     0.634 ns
  Predicted time 17180000.000 us     less counted time     2.000 us
  
                       Histogram Results                      
  171800 GR:   6055 nom,  6054.0000 avle    ≤6005: 1  =6054: 171799  
  171800 GF:    195 nom,   196.0000 avle    =196: 171800  
  Total average (less edges) =  6250.0000, nomCy NA, total nom 6250


  Making state machine instances
  System frequency  = 125000000 Hz,      8.00 ns
  Counts per second =  62500000 Hz,     16.00 ns
    Wave frequency  =     10000 Hz, 100000.00 ns
  About to get 344000 edges in 17.2 sec. with wave type 3
  Processed 344000 items with 64 skips in 17.206940 sec
  
  Clock time     17206939 us    Clock-count total diff   244.000 us
  Counted time   17206696.000 us  Clock-count avg diff     0.709 ns
  Predicted time 17200000.000 us     less counted time -6696.000 us
  
                       Histogram Results                      
  172005 GR:   6055 nom,  6055.0000 avle    ≤6005: 1  =6055: 171933  ≥6105: 71
  171995 GF:    195 nom,   195.0000 avle    ≤145: 62  =195: 171905  ≥245: 28
  Total average (less edges) =  6250.0000, nomCy NA, total nom 6250

200 MHz system clock run
---------------------------------------------

In the thonny shell window, I issued commands to change RP2040
frequency to 200 MHz: ``from machine import freq; freq(200000000);
freq()``, which displayed 200000000.  Then, running 8b gave::

  Making state machine instances
  System frequency  = 200000000 Hz,      5.00 ns
  Counts per second = 100000000 Hz,     10.00 ns
    Wave frequency  =     10000 Hz, 100000.00 ns
  About to get 343500 edges in 17.2 sec. with wave type 3
  Processed 343500 items with 2 skips in 17.364033 sec
  
  Clock time     17364033 us    Clock-count total diff    32.000 us
  Counted time   17364000.000 us  Clock-count avg diff     0.093 ns
  Predicted time 17175000.000 us     less counted time -189000.000 us
  
                       Histogram Results                      
  171751 GR:   9688 nom,  9687.0000 avle    ≤9638: 1  =9687: 171715  ≥9738: 35
  171749 GF:    312 nom,   313.0000 avle    ≤262: 1  =313: 171748  
  Total average (less edges) = 10000.0000, nomCy NA, total nom 10000

Note different rising and falling edge counts, and 36 rising-edge
entries more than 50 counts away from expected count (nominally 9688).

----------------------


Make-up Decrements Tests
----------------------------

Move, set, and push operations to store mark words and values use ~ 11
cycles per rising edge + falling edge sequence, hence 5.5 decrements
get missed, which requires 11 extra decrements.  Of those 11 extra
decrements, half are make-up decrements and half are keep-up
decrements.  Test results like those shown below bear upon tuning
the number of make-up decrements to use in the code, and how to
proportion them between falling- or rising-edge stores.  These tests
were run at system frequency = 120 MHz, wave frequency = 6000 and 6003
Hz, with waves of 50% duty cycle, so we should have equal R and F
Bins, and equal Counts.  * means unequal numbers.  A Bin number is a
measured cycle-counter value.    An "R Count" or "F Count" is how many
times the Bin value occurred during a test run.

=========  ==========  ========  =========  ========  =========
Wave Freq   FR Split    R Bin     R Count    F Bin     F Count
=========  ==========  ========  =========  ========  =========
   6000      4-7*        4999       6999      5001       6999
   6000      5-6*        4999       6999      5001       6999
   6000      6-5         5000       6999      5000       6999
   6000      7-4         5000       6999      5000       6999
   6000      8-3*        5001       6999      4999       6999
---------  ----------  --------  ---------  --------  ---------
---------  ----------  --------  ---------  --------  ---------
   6003      4-7*        4996       6999      4999       6999
   6003      5-6*        4997       6999      4998       6999
   6003      6-5*        4997       6999      4998       6999
   6003      7-4*        4998       6999      4997       6999
   6003      8-3*        4998       6999      4997       6999
=========  ==========  ========  =========  ========  =========

The 6-5 split seems more likely than 7-4 to be technically correct --
it is closer to manual counts of cycles used in the F, R cases than is
7-4.  One way to know for sure would be use of a PIO SM simulator
program.  However, the simulator I'm aware of takes C code rather than
Python, so its use would entail translating some amount of 8b from
Python into C. Not likely to happen.  A few other tests follow, all at
system frequency = 120 MHz and waves of 50% duty cycle, at several
wave frequencies, splits, and numbers of edges.  In some cases -- eg
the 330 to 490 Hz lines -- results may mislead, because many counts
(5-50%) were not in the main bin.  The histo lines for those runs show
bin counts, but the simple tests in ``showFRSplit()`` don't properly
cope.  Note, the square waves for wave frequencies like 330-333 and
490 are imperfect; at frequent intervals, the wave state machine clock
adds or drops a system cycle as dictated by the fractional-division
state machine clock generator.  Thus, pulse widths at those
frequencies may vary (fairly repeatably, see 331 Hz results) plus or
minus about 8 nanoseconds, enough to push results into an adjacent
histo bin.  Here are Histogram Results for representative 331 Hz
runs at 7-4, 6-5, and 6-5 splits, which clearly indicate that 6-5 produces more-accurate results than 7-4::

   350 GR:  90634 nom, 90634.9375 avle    =90634: 22  =90635: 327  [90636-90639): 1  
   350 GF:  90634 nom, 90633.9219 avle    ≤90584: 1  =90633: 25   =90634: 324  

   350 GR:  90634 nom, 90634.4375 avle    =90634: 199  =90635: 151  
   350 GF:  90634 nom, 90634.4375 avle    ≤90584: 1  =90634: 196  =90635: 153  

   350 GR:  90634 nom, 90634.4375 avle    =90634: 196  =90635: 154  
   350 GF:  90634 nom, 90634.4297 avle    ≤90584: 1  =90634: 199  =90635: 150

On the other hand, pulse widths for 500 Hz and 600 Hz have
variation probably on the order of picoseconds.

=========  ==========  ========  =========  ========  =========
Wave Freq   FR Split    R Bin     R Count    F Bin     F Count
=========  ==========  ========  =========  ========  =========
    330      7-4*       90910        203     90909        203
    331      7-4*       90635        324     90634        327
    331      7-4*       90635        327     90634        324
    331      7-4*       90635        327     90634        324
    331      7-4*       90635        327     90634        324
    331      7-4*       90635        327     90634        324
    332      7-4*       90362        331     90361        329
    333      7-4*       90091        198     90090        207
    490      6-5        61224        184     61224        184
    497      6-5*       60362        295     60362        286
    500      6-5        60000        349     60000        349
    600      6-5        50000        349     50000        349
    600      7-4        50000        349     50000        349
=========  ==========  ========  =========  ========  =========

----------------------

Note, code tests were on an RP2040 running MicroPython v1.25.0, via
Thonny 3.3.14 IDE on an ubuntu.22.04 Linux system.  ::

    MicroPython v1.25.0-preview.160.gc73204128 on 2024-12-30; Raspberry Pi Pico with RP2040
    Type "help()" for more information.
    >>> 

jiw - 21 Jan 2025
