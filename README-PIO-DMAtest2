.. -*- mode: rst -*-  #  RM for littlePIO-DMAtest1.py - jiw - 1 Jan 2025
..  To view this in html in browser, use `restview README-lPDt.rst`
..  Browser page will update whenever a changed version is stored.

========================================
PIO-DMAtest2
========================================

**Aim:** `PIO-DMAtest2` is a test / demo of putting RP2040 PIO State
Machine output into memory, via DMA transfer with DMA interrupts and
chaining.  It acts as follows:

• Creates a state machine `smx` to increment a counter by 3 between stores
• Sets up three DMA channel that get words from `smx` and store into buffers
• Runs a wait loop that analyzes current results each time a buffer fills

Note, `smx` has its two 4-word Rx and Tx fifos combined into one
8-word Rx fifo.

Three sets of example output are shown below, taken with state machine
`smx` producing words at 20, 25, and 30 KHz.  After each full-buffer
interrupt and callback, the main thread prints out action times,
buffer min and max, and sequence-check results.  At 40 KHz, tests
didn't complete -- data accumulated faster than one CPU could process
and it crashed.  Using both RP2040 CPUs, speeds over 50 KHz would be
feasible.

The first part of output for each test case is like the output from
`PIO-DMAtest1`.  We have system frequency = 125000000, followed by
state-machine data -- step frequency, steps per cycle, and cycle
frequency.  After some headings, 15 lines of data appear.  Each data
line shows a numbered entry with the time of a DMA interrupt, how long
until callback and processing, and buffer analysis -- min, max,
sequence check.  For example::

    Entry    Interrupt   Microseconds to    First    Range     OK
     #  DMA#  time, us  Callback & Report   value   min-max   steps
     3   0     153779      25      200       1155  1155-1344   63

This shows the third entry for DMA channel 0.  The third interrupt for
that channel occurred about 153779 microseconds after DMA channels
were created.  About 25 us after the interrupt, whose handler
scheduled a callback, the callback routine started.  That routine
stored interrupt and callback times, and increased the in-records
index, `rri`.  About 200 us after the interrupt, the main thread's
busy loop saw `rro<rri` and wrote the data line shown, to say that DMA
channel 0's buffer's word 0 holds 1155; that min and max are 1155 and
1344; and that 63 of the buffer's 64 entries are 3 more than the
previous entry, all as expected for the third buffer fill for channel
0 of 3 channels.  (Each buffer fill overwrites a buffer.)  Note, 1155
= 3 + 3*3*64 = starting value + chans*fills*words.  

---------------------------

Note, code was tested 19 Jan 2025 on an RP2040 running MicroPython v1.25.0, via
Thonny 3.3.14 IDE on an ubuntu.22.04 Linux system.  ::

    MicroPython v1.25.0-preview.160.gc73204128 on 2024-12-30; Raspberry Pi Pico with RP2040
    Type "help()" for more information.
    >>> 

